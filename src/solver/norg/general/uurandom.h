#pragma once

/*
uniform unit random number generator [0, 1) using STL
adapting to both serial and parallel simultaneously

a uniformly distributed real random number in [0, 1) 
is generated by every operator() calling

NOTE: mpi_init_random must be called first for a parallel code

code developed by
	Rong-Qiang He (rqhe@ruc.edu.cn, RUC, China)
date 2021-01-23
*/

#include <random>
#include <iostream>
#include <iomanip>

// uniform unit random number generator [0, 1) using STL
// adapting to both serialand parallel simultaneously
// a uniformly distributed real random number in[0, 1)
// is generated by every operator() calling
// NOTE: use myid to make UURandom for a parallel code
class UURandom {
private:
	std::default_random_engine generator;
	std::uniform_real_distribution<double> distribution;
private:
	double uniform_unit_random() { return distribution(generator); }
	unsigned parallel_seed(int myid, unsigned seed_global_shift) {
		// you can change global_shift to get a new set of parallel seeds
		const double pi = 3.14159265358979323846264338327950;
		std::mt19937 mtg(1);
		for (int i = 0; i < myid; i++) {
			Real tmp0 = mtg();
			Real tmp1 = mtg();
			Real tmp2 = mtg();
		}
		return mtg() + mtg() + unsigned(pi * mtg()) + seed_global_shift;
	}
public:
	UURandom(int myid = 0, int seed = 1) : generator(seed), distribution(0., 1.) {
		init_random(myid, unsigned(seed));
	}

	// init random number generator with a new seed
	void init_random(int seed) { generator.seed(seed); }

	// init random number generator with a different new seed for each different myid
	void init_random(int myid, unsigned seed_global_shift) {
		unsigned seed = parallel_seed(myid, seed_global_shift);
		std::cout << "random seed = " << std::setw(10) << seed
			<< " with myid = " << myid << std::endl;
		generator.seed(seed);
	}

	double operator()() {
		return uniform_unit_random();
	}
	void operator()(VecReal& v) {
		for_Int(i, 0, v.size()) {
			v[i] = (*this)();
		}
	}
	void operator()(VecCmplx& v) {
		for_Int(i, 0, v.size()) {
			v[i] = Cmplx((*this)(), (*this)());
		}
	}
};
